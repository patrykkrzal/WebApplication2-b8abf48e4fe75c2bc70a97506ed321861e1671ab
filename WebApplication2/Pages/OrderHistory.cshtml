@page "/OrderHistory.html"
@{
 ViewData["Title"] = "Historia zamówień";
}

@section Styles {
 <link rel="stylesheet" href="/css/order-history.css" />
}

<h1 class="winter-title">📜 Historia zamówień</h1>
<div class="content-section">
 <div class="frost-effect">
 <div id="orders" class="mt-3"></div>
 </div>
</div>

@section Scripts {
 <script>
 async function loadOrders() {
 const el = document.getElementById('orders');
 try {
 const res = await fetch('/api/orders', { credentials: 'include' });
 if (!res.ok) {
 el.textContent = 'Nie można pobrać zamówień.';
 return;
 }

 const list = await res.json();
 console.debug('loadOrders response', list);
 if (!Array.isArray(list) || !list.length) {
 el.textContent = 'Brak zamówień.';
 return;
 }


 try {
 el.innerHTML = list.map(o => renderOrder(o)).join('');
 } catch (renderErr) {
 console.error('renderOrder failed', renderErr);
 el.textContent = 'Błąd renderowania zamówień.';
 }
 }
 catch (err) {
 console.error('loadOrders error', err);
 el.textContent = 'Błąd: ' + (err.message || err);
 }
 }

 function deriveStatus(o) {
 if (o.Was_Rejected || o.was_Rejected) return 'Usunięto';

 let status = o.Status || o.status || '';
 if (status) return status;

 const wasReturned = o.Was_It_Returned || o.was_It_Returned;

 const items = o.Items || o.items || o.OrderedItems || o.orderedItems || [];

 const anyOutReserved = Array.isArray(items) && items.some(i =>
 ((i.Is_In_Werehouse === false) || (i.is_In_Werehouse === false) || (i.Equipment && i.Equipment.Is_In_Werehouse === false)) &&
 ((i.Is_Reserved === true) || (i.is_Reserved === true) || (i.Equipment && i.Equipment.Is_Reserved === true))
 );

 if (wasReturned) return 'Zakończona realizacja';
 if (anyOutReserved) return 'Do oddania';

 return 'W trakcie realizacji';
 }

 // helper map
 const _typeNameMap = {0: 'Snowboard',1: 'Gloves',2: 'Poles',3: 'Helmet',4: 'Skis',5: 'Goggles' };
 const _sizeNameMap = {0: 'Universal',1: 'Small',2: 'Medium',3: 'Large',4: 'Xl' };
 function normalizeType(val) {
 if (val === null || val === undefined) return '';

 if (typeof val === 'object') {
 if (val.Type !== undefined) return normalizeType(val.Type);
 if (val.type !== undefined) return normalizeType(val.type);
 }
 const s = String(val).trim();
 if (!s) return '';
 // if numeric index
 if (/^\d+$/.test(s)) {
 const n = parseInt(s,10);
 return _typeNameMap[n] || s;
 }

 return s.charAt(0).toUpperCase() + s.slice(1);
 }
 function normalizeSize(val) {
 if (val === null || val === undefined) return '';

 if (typeof val === 'object') {
 if (val.Size !== undefined) return normalizeSize(val.Size);
 if (val.size !== undefined) return normalizeSize(val.size);
 }
 const s = String(val).trim();
 if (!s) return '';
 if (/^\d+$/.test(s)) {
 const n = parseInt(s,10);
 return _sizeNameMap[n] || s;
 }
 // capitalize
 return s.charAt(0).toUpperCase() + s.slice(1);
 }

 function safeText(v) { if (v === null || v === undefined) return ''; return String(v); }

 function getUserFullName(o) {

 const user = o.User || o.user || null;
 const parts = [];
 function pushIf(v) { if (v !== null && v !== undefined && String(v).trim()) parts.push(String(v).trim()); }
 if (user) {
 pushIf(user.FirstName || user.firstName || user.First_name || user.first_name);
 pushIf(user.LastName || user.lastName || user.Last_name || user.last_name);
 }
 pushIf(o.UserFirstName || o.UserFirst_Name || o.UserFirst_Name);
 pushIf(o.UserLastName || o.UserLast_Name || o.UserLast_Name);
 if (!parts.length && user) {
 pushIf(user.UserName || user.userName || user.Email || user.email);
 }
 return parts.join(' ').trim();
 }


 function renderItemsList(o) {
 const items = o.Items || o.items || o.OrderedItems || o.orderedItems || [];
 const grouped = o.ItemsGrouped || o.itemsGrouped || o.ItemsGrouped || [];
 let lines = [];

 if (Array.isArray(grouped) && grouped.length) {
 grouped.forEach(g => {
 const t = normalizeType(g.Type ?? g.type ?? g.TypeIndex ?? g.Type_Id ?? g.TypeName);
 const s = normalizeSize(g.Size ?? g.size ?? g.SizeIndex ?? g.Size_Id ?? g.SizeName);
 const cnt = g.Count ?? g.count ?? '';
 lines.push(`${t} ${s}`.trim() + (cnt ? ` × ${cnt}` : ''));
 });
 }
 else if (Array.isArray(items) && items.length) {
 items.forEach(i => {
 // possible shapes: root Type/Size or nested Equipment
 const rawType = i.Type ?? i.type ?? (i.Equipment && (i.Equipment.Type ?? i.Equipment.type)) ?? (i.Equipment && i.Equipment.TypeName) ?? '';
 const rawSize = i.Size ?? i.size ?? (i.Equipment && (i.Equipment.Size ?? i.Equipment.size)) ?? (i.Equipment && i.Equipment.SizeName) ?? '';
 const t = normalizeType(rawType) || 'brak nazwy';
 const s = normalizeSize(rawSize) || '';
 const qty = (i.Quantity ?? i.quantity ?? i.Qty ?? i.qty) ||1;
 lines.push(`${t}${s ? ' ' + s : ''} × ${qty}`);
 });
 }
 else {
 const rentedTxt = o.Rented_Items ?? o.rented_Items ?? o.rented_items ?? '';
 if (rentedTxt) lines.push(rentedTxt);
 }

 // sanitize lines: remove literal 'undefined' and trim
 return lines.map(l => l.replace(/undefined/g, '').trim()).filter(Boolean).join(', ');
 }

 function formatDateShort(raw) { if (!raw) return ''; const d = new Date(raw); if (isNaN(d.getTime())) return ''; return d.toLocaleDateString('pl-PL'); }

 function renderOrder(o) {
 const id = o.Id ?? o.id;
 const price = Number(o.Price ?? o.price ??0).toFixed(2);

 const userName = getUserFullName(o) || ((o.User && (o.User.UserName || o.User.userName)) || '') || ((o.UserFirstName || o.UserFirst_Name || '') + ' ' + (o.UserLastName || o.UserLast_Name || '')) || o.User?.UserName || '';

 const dateRaw = o.OrderDate ?? o.orderDate;
 const d = dateRaw ? new Date(dateRaw) : null;
 const dateStr = d && !isNaN(d.getTime()) ? d.toLocaleString('pl-PL') : '';

 const dueRaw = o.DueDate ?? o.dueDate;
 const due = dueRaw ? new Date(dueRaw) : null;
 const dueStr = due && !isNaN(d.getTime()) ? due.toLocaleDateString('pl-PL') : '';

 const statusText = deriveStatus(o);
 const lower = statusText.toLowerCase();

 const badgeClass =
 lower.includes('usun') ? 'status-deleted' :
 lower.includes('oddania') ? 'status-owned' :
 lower.includes('zakończ') ? 'status-finished' :
 'status-pending';

 const itemsSummary = renderItemsList(o) || '';
 const basketText = o.Rented_Items ?? o.rented_Items ?? o.rented_items ?? '';
 const showSummary = !basketText;

 // Show due date when server provided DueDate and order is not returned
 const wasReturned = o.Was_It_Returned || o.was_It_Returned;
 const shouldShowDue = dueStr && !wasReturned;

 // final HTML, sanitize userName and itemsSummary to avoid 'undefined'
 const safeUser = (userName || '').replace(/undefined/g, '').trim();
 const safeItems = (itemsSummary || '').replace(/undefined/g, '').trim();

 return `
 <div class='order-box'>
 <div class='order-title'>
 <strong>Zamówienie #${safeText(id)}</strong>
 <span class='status-badge ${badgeClass}'>${statusText}</span>
 </div>

 <div>
 Data: ${dateStr} | Suma: ${price} zł
 ${shouldShowDue ? `<span class='due'>| Termin zwrotu: ${dueStr}</span>` : ''}
 ${safeUser ? `<div class='order-group'><strong>Użytkownik:</strong> ${safeUser}</div>` : ''}
 </div>

 ${basketText ? `<div class='order-group'><em>Z koszyka:</em> ${safeText(basketText)}</div>` : ''}
 ${showSummary && safeItems
 ? `<div class='order-items order-items-summary'>Wypożyczone przedmioty: ${safeItems}</div>`
 : ''}
 </div>
 `;
 }

 document.addEventListener('DOMContentLoaded', loadOrders);
 </script>
}